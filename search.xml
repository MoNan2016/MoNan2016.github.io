<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转载】网络流总结]]></title>
    <url>%2F2019%2F05%2F24%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法总结</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期心声与杂谈]]></title>
    <url>%2F2019%2F05%2F06%2F%E8%BF%91%E6%9C%9F%E5%BF%83%E5%A3%B0%E4%B8%8E%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[我想把最近发生的一些事情讲讲个人看法。 停课其实对信息学竞赛真的很有帮助，之前有很多搞文化课的人和别的四奥的人都认为我们停那么多课有没有必要，其实是有必要的。学好OI必须付出更多的时间。 打什么比赛都要做上一层次比赛的训练题、真题，很有效。 怎么权衡竞赛与文化课这个问题，我觉得暂时应该竞赛优先。而且停课就应该专心搞好竞赛，分心会很麻烦。我不赞成学校领导所说兼顾这一说法，至少对我来讲是不行的。因为就摆了一个那么强的同级同伴在那里，没有不去努力赶超的理由。所以D同学可以分配很多时间来学文化课，是因为他竞赛功力比我好很多，我需要大量精力去补，现在还不补的话，高一能不能去省选都是一个问题，何况省队呢？ 政策那么乱，但我坚信坚持下来的人一定可以的，清北不可能放着那么多优秀的学生不要而去要那些死读文化课死刷题的人吧。 有一个好兄弟，文化课比我还差（我停课他不停），要努力啊，不要连六高线都过不了吧。 我感觉有另一个好兄弟竞赛太颓了，签完约之后就一直颓，不知道他在搞什么，又不见他和他亲爱的同桌发展的多好，又不见他文化课有多好，你再不发力，怎么500+啊？ 还有一个自小玩大的好兄弟，感觉被他的“妹妹”吸干了（虽然他“妹妹”文化课很好，他文化课竞赛两开花），做事变得很……，原本数竞的种子选手也开始颓了，这样不行啊。 DQA为什么这么强，是有他的道理在的。就讲一方面吧，我们当时说停课的每一天假如没有什么大事，都要下去操场锻炼，至少跑5圈。有几天，我觉得有别的事做，或者是刚下完雨不久，就不想下去了。此时我总能看见DQA坚持不懈的身影，我也感到很羞愧。见贤思齐，我也开始每天无论如何都坚持做好计划中的每一件事。 为什么学校开始不太支持竞赛啊？难道我们竞赛的人都是去玩的吗？我们就比文化课的学生走捷径、偷懒、愚蠢了吗？ 最近得知有一个我感觉很好的朋友要离开不签六高的黄埔，本来ta总是说我有很多要做的事怎么都不紧不慢的呢，我说的可以继续三年、七年甚至一生，怕什么？现在我怕了。很怕。很不解。觉得挺失落的（不知道为什么）。预祝ta在新的高中学习生活愉快，大学可以考回到一处啊！（THU见！） 有一个我认识的朋友，他告诉我，他之前一直跟一个同班的女生关系算好吧，后来不知道为什么就冷了。但是保持着联系，一直到了初三上学期末，还挺好的。但现在就开始不被理睬了，有可能是那个女生前面坐的那个男生给她灌了不知道什么迷汤吧，他问我怎么解决？我说那个男生怎么样？他跟我讲，那个人虽然搞搞物理竞赛，但是前程肯定不如他（我那个朋友，他搞另外一科竞赛，很有恒信，有很大的潜力）啊，而且文化课非常的差，还很不负责任，人品也不太好，表面上嬉皮笑脸的、真正想干什么别人都不知道，而且他可能玩一玩那个女生就算了，分了他不会这么样，但是对我那个朋友喜欢的女生而言，是一种莫大的伤害。我告诉我的朋友，你没有不争取的理由，那种狗人你凭什么打不赢他？你必须赢！ 暂时讲着这么多先，有一些跟OI无关的大家可以略过，只不过我印象深刻，而且觉得很有必要分享一下，故此写下来。 要回去复习文化课了。]]></content>
      <categories>
        <category>其他</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月停课总结]]></title>
    <url>%2F2019%2F05%2F06%2F2019%E5%B9%B44%E6%9C%88%E5%81%9C%E8%AF%BE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我来简略讲一下这个月的一些学习情况与体会。 大概是因为上年联赛打完之后感觉自己什么都不会，但是又很想在OI方面做出点成绩，所以成绩一直都往下跌，大失原来水准。后来还是勉强签了个六高黄埔，然后我就感觉省选的东西好像什么都不会（跟上年打提高之前一样），就借鉴MJ师兄的做法，和DQA一起停了全天的课。 初步感觉是压力没有去年为了比赛而停课时的大，而且可以仔细把每个要点都搞清楚，学精学透。还是很值得的。 本来列了三周的计划表，但是由于学校还是有很多活动（毕竟初三嘛）要参加，加上打了几场计划外的比赛（加上补了一些之前不会的题），所以大概完成了两周的主要内容（第三周数据结构类没有做）。 第一、二周把后缀数组和后缀树、后缀自动机都学完了，而且做了一部分的题目，偏基础，但是后缀自动机还是没有学透（自动机的精华没搞懂），还要通过做题来巩固。收获是把后缀数组的10+个常用模型都了解了一下，做了6、7个的样子吧。 停课期间参加了体育中考，没有发挥出最好的水平，不是我初中阶段最好的成绩，但一样简单地获得了60分的满分。 不过感觉两边兼顾真的很烦，文化课会浪费掉大量的OI学习精力和时间。 第三、四周学习了莫比乌斯反演和狄利克雷卷积、杜教筛、数论分块等有关的数学知识。虽然我数学功底比较扎实，但是还是花费了不少的时间去理解。做的题同样也是偏基础，也有一些变体的题（Eg. 【GDOI2018Day2T1】谈笑风生）。不过感受到做这类题目的关键都是推式子，各种和式积式的变换、gcd约数倍数等的变换都是需要理解透彻才能推出来的，这些需要多加练习。 除了计划中的练习，还参加了若干场提高组和省选的模拟赛（也把今年的GDSOI打了）。情况证明，联赛部分我的水平提高了很多（甚至可以AK几场Day1了，与去年相比），但是省选部分我会的知识点太少了，做的题也太少了，思维能力、代码实现能力、调试错误能力、时间分配能力和临场应变能力都需要继续训练加强。 在机房停课的最后一天听了学长们参加GDSOI2019的分享，我觉得麦老大说的很对啊，我们做题的量不够是一个问题，更严重的是做题做完就不记得了，更加不会举一反三，这点要修正。还有别的学长们在赛场上因为策略与心态问题造成的后果也值得我们思考与改进。现在政府对于竞赛的政策很乱，我们一定要坚持下来，争取NOIP2019 500+，高一进个省队吧。毕竟现在还能坚持下来的人都抱着视死如归、考不上大学的那种心态去拼的了，没有不退役的人会不想着冲进国家集训队的。比我们强的人都在努力，那我们假如不努力怎么行呢？ 停课期间参加了一模考试，如我所料，文科全都一败涂地，理科也没有发挥好，本来可以获得更高的分数的数理两科都不尽人意，在口语考试中获得高分的我也没有一帆风顺下去。特别是政治学科，需要加强。 因为一模考的不好的原因，而且也只剩一个半月了，我回去上文化课了，毕竟上个六中线说难不难，但是对我这种全年心思都花在竞赛上的人来讲说简单也不太简单。不过相信按照我的能力一个半月足以让我考上六中线，可能730+或者740+都是可以的，发挥的好的话还有很大可能750+。 这段时间虽然停课，但还是很忙，有一些没有写的题解和总结有空补（可能要中考后了）。有一些做过的题的思路还是很棒的，有一些细节更加应该注意一下。 中考后我会马上参加训练的，毕竟把每场比赛都当成最后一战这种思想很有用。 中考必胜！ 联赛必胜！]]></content>
      <categories>
        <category>其他</category>
        <category>计划</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LOJ2084】【NOI2016】网格]]></title>
    <url>%2F2019%2F04%2F24%2F%E3%80%90LOJ2084%E3%80%91%E3%80%90NOI2016%E3%80%91%E7%BD%91%E6%A0%BC%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4199】【NOI2015】品酒大会]]></title>
    <url>%2F2019%2F04%2F20%2F%E3%80%90BZOJ4199%E3%80%91%E3%80%90NOI2015%E3%80%91%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[题解知识点：后缀树，后缀数组，LCP，树形DP 分析：这道题是我初学后缀结构的近期训练最后一道练习题，一开始只想到$\Theta(n^2)$的方法和“不存在10相似”的情况。后来看了一年前炜隽哥哥的slide，才知道真正的做法。 这道题的题意是这样的：我们要求出有多少个子串的LCP大于等于每个$i\in [1,n]$中的$i$，第二问要求出每个组当中$a[i]$值两两乘积中最大的一个是多少（而且$a[i]\in \mathbb Z$，也就是说有可能有非正数）。我们发现直接做LCP大于等于的情况很不好写，所以先考虑求出等于的情况，而第二问也不算核心，直接用一个DP记录一下就好了，可以先放一放。 下面先简介两种方法： 方法一：后缀数组第一问实际上是求有多少个区间$[l,r]使得height[l..r]的最小值为i$，然后我们考虑用并查集维护后缀集合，从$n-1$到$0$枚举每一个可能的后缀长度$i$，在此之前，每个集合内部的任意两个后缀的$LCP$ 都大于$i$。这时假如有两个排名相邻的并且$LCP$ 为$i $的后缀，我们就可以把它们所处的集合合并起来。 具体地，把$height$值从大到小排个序，然后然后把$ans[heght]$的值加上当前合并的两个相邻的集合的大小乘积（因为根据乘法原理，每个区间中，依次枚举左右端点，是有乘积中情况）。然后合并集合。 记录的时候要注意，因为我们合并的时候都是合并排名相邻的一些后缀，所以出现在一个集合中的所有后缀必定是连续的，所以我们只需要记录每个集合的左右端点就可以了。合并的时候也只用更改端点的值就好了。 对于第二问，我们在合并的时候可以把$a[i]$的值也顺路合并（具体方法可见方法二，大同小异）。然后就做完了。 时间复杂度：$\Theta(n\log_2n)$ 方法二：后缀树把后缀树建出来之后，我们直观地发现LCP就变成了LCA（两个点的LCA节点在后缀树上对应的节点的长度值就是LCP的长度）。而每个子树下的后缀节点的个数，就是那棵树的贡献。 如图： 对于每个蓝点的子树统计好后缀节点的个数，然后对其LCA（红点）进行统计，然后途中的“len”就是他们LCP的长度（假设从红点往上一直走了很多个节点后到达了整棵后缀树的根节点（黄点），之间的距离（边权之和）就是len）。 具体地，我们可以先建出后缀树。然后进行树形DP（理解为DFS也行）。怎么统计后缀节点的个数呢？这个相当简单，只需要对其子节点的子树信息进行累加就可以了，而我们知道怎么样的节点才可能是后缀节点。在建树的时候，直接加进去的一定是后缀点，通过一条原来很长完整的边（里面包含不止一个字符的）的分裂得到的点，一定不是后缀点，这个在建树的时候判断一下就好了。但是答案一定是这个吗？ 当然不是！ 回到那幅图，考虑现在在红点统计答案。这时候的单位贡献就是$len$,小学数学告诉我们：$单位贡献\times数量=总共贡献$，所以我们现在统计数量。数量是有多少个后缀节点对（无序的）产生的贡献，考虑对蓝色点标号$1,2,3,\cdots,k$,每个蓝点为子树（包含蓝点，就是说假如蓝点是后缀点，那也算进去）的总共后缀节点数为$v_1,v_2,v_3,\cdots,v_k$,那么对于红点的贡献数量就是$\displaystyle\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}v_i\times v_j$,这样可以保证不重不漏（大家可以把那四个蓝点的情况直接写出来，看一下对不对，我当时推的式子是$v_1\times v_2+v_1\times v_3+v_1\times v_4+v_2\times v_3+v_2\times v_4+v_3\times v_4$),可以发现它我上面给出的双重和式的意义是一样的。 但是这个式子求出来的最大复杂度是$\Theta(n^2)$的，所以一定不可以通过。 考虑对式子进行展开，先对原式$\times2$,然后再$\div2$, 第一步，我们得到$\text{原式}=\frac{\displaystyle\sum_{i=1}^{k}\sum_{j=1\land j\not =i}^{k}v_i\times v_j}{2}$(举例，就是$\frac{v_1\times(v_2+v_3+v_4)+v_2\times(v_1+v_3+v_4)+v_3\times(v_1+v_2+v_4)+v_4\times(v_1+v_2+v_3)}{2}$) 第二步，我们发现这个式子好像差了点什么，所以继续添加项，添加为$v_1\times(v_1+v_2+v_3+v_4)$，在这里我们多加了一个$v_1^2$,所以把它减去。此时假如大家把后面几项也这样拆开，就可发现后面都是$(v_1+v_2+v_3+v_4)$，前面是$v_i\times$后面的那个括号。初中数学告诉我们，我们应该合并同类项，变成$(v_1+v_2+v_3+v_4)^2$,这样，就是非常简便的了。 第三步，对第二步的式子进行化简，写成原式$=\frac{(\displaystyle\sum_{i=1}^{k}{v_i})^2-\displaystyle\sum_{i=1}^{k}{v_i^2}}{2}$ 然后这个式子就可以$\Theta(n)$的时间内求出来，可以接受（具体操作就是对于每一个子节点求一次和与一次平方和就好了）。这种推式子的方法好像和很多题解的方法不同，但是本质要求都是一样的。 对于第二问，我们要设法更新$a[i]$的最大值。因为此题中$a[i]$的值是可正可负的，所以就不可以只记录每个节点下的最大和次大值。参照我去年做过的一道环形DP题（【IOI1998】Polygon）中的思想，同时记录下最大和次大与最小和次小值。因为如果最小和次小值是个负数，两者相乘会变成一个正数，这个正数的有可能比最大值和次大值的乘积要大，所以可以用这个来更新答案。 不过千万注意，一定要弄懂其中的逻辑关系。这里计算出来的值（最小次小的乘积，最大次大的乘积）都只是用来更新$ans[len]$的，而合并到父节点（上图的红点）的信息，依旧是原来的最大最小等等的值（就是更新答案的时候一直都是用原来的信息，不是乘积）。所以说，我们一直用原有的信息去更新每一个值，而不是计算后更新。 具体地，初始化一定要做好。把每个后缀节点的初始最大最小值设为$a[i]$，而次大次小分别设成负无穷和正无穷。加入非后缀节点时（分裂节点），把四个值分别设成正负无穷（因为这些节点本来就需要别的点去更新它们，它们自己本来就没有权值）。而什么东西都没有的根节点，也要设成正负无穷。在树形DP的时候，假如我们需要更新父节点$u$的信息，当前枚举到的子节点是$v$，我们就可以把$u$和$v$的最大最小次大次小拿出来，大的排一遍序，取最大那两个更新$u$节点的信息。对于小的值同理，也是拿出来排一遍序，然后取最小的两个放回去。此处经过计算可得，冒泡排序是理论上计算次数相对少的而写起来又很方便的一种排序，每一次更新只用12次的运算（远远小于快排），所以常数会小很多。不过看到有一种可以直接更新的方法，就是分别比较两个最值，然后直接往后更新，感觉这种好像更快，但是当时我觉得写这种好像风险有点大，怕写WA。如果当前的统计完发现整棵子树的大小小于2，那么就可以离开了，因为构不成两两之间的 LCP了，这样没法更新答案（不过子树大小还是要更新的，后面有用）。 最后的求一次后缀和与后缀最大值，就从后面往前更新（因为题目说$r$相似的两个串同时也是$r-i$相似的），所以假如当前的后缀和还是$0$，那么就把最大值也设成$0$（在计算过程中，最大值有可能是一些不可预知的数）。然后注意细节，注意更新的顺序。 时间复杂度：$\Theta(n)$ 小结：对比两种不同的方法，其实本质上是相同的。方法一中合并$height$的过程就是模拟了后缀树上两两合并LCA的过程，只不过树形结构更加便于理解和实践。两种方法各有优劣，但是理论复杂度上后缀树会更佳一些。实现上，方法一难在第一问的合并（好像挺难写的），方法二难在第二问的统计$a[i]$的答案和细节调错上，毕竟树形结构难以调试，细节超多。不用后缀自动机解题的原因是，后缀自动机想起来没有后缀树好想，但是实现起来却与后缀树大同小异，还要用$parents$树进行再一次的转化，没有这个必要，毕竟树的性质是比DAG要多的，要更为方便的。 代码：这道题我一共交了四次才AC。我用的是方法二（感觉更好写）。 可以看见其实细节很多。我觉得对于更新第二问的答案时是最为麻烦的。大家千万小心。 第一次： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300010;typedef long long ll;int n,m,tot,cnt,tp,rt,head[maxn];ll b[maxn];const ll inf=1000000007;char s[maxn];struct node&#123; int fa,p,len,siz; ll _min1,_max1,_min2,_max2; int trans[27],son[27];&#125;a[maxn&lt;&lt;1];struct data&#123; int nxt,to;&#125;edge[maxn];struct result&#123; ll sum,val;&#125;ans[maxn];#define min(a,b) (a&lt;b?a:b)#define max(a,b) (a&gt;b?a:b)#define isdigit(c) (c&gt;=48&amp;&amp;c&lt;=57)#define swap(a,b) (a^=b^=a^=b)ll read()&#123; ll x=0,f=1; char c=getchar(); while (!isdigit(c)) f=c=='-'?-1:1,c=getchar(); while (isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*f;&#125;int ins(int u,int p,int c)&#123; int x=++tot,v; a[x].len=a[u].len+1; a[x].p=p; a[x].siz=1; a[x]._min1=a[x]._max1=b[p]; a[x]._min2=inf; a[x]._max2=-inf; for (;u&amp;&amp;!a[u].trans[c];a[u].trans[c]=x,u=a[u].fa); if (!u) a[x].fa=rt; else &#123; v=a[u].trans[c]; if (a[v].len==a[u].len+1) a[x].fa=v; else &#123; int w=++tot; a[w]=a[v]; a[w].len=a[u].len+1; a[w]._max1=a[w]._max2=-inf; a[w]._min1=a[w]._min2=inf; a[w].siz=0; a[v].fa=a[x].fa=w; for (;u&amp;&amp;a[u].trans[c]==v;a[u].trans[c]=w,u=a[u].fa); &#125; &#125; return x;&#125;void cmp(int u,int v)&#123; int i,j; ll p[10]; memset(p,0,sizeof(p)); p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[v]._max1; p[4]=a[v]._max2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&lt;p[j+1]) swap(p[j],p[j+1]);/* for (i=1;i&lt;=4;i++) printf("%d ",p[i]);*/ a[u]._max1=p[1]; a[u]._max2=p[2]; memset(p,0,sizeof(p)); p[1]=a[u]._min1; p[2]=a[u]._min2; p[3]=a[v]._min1; p[4]=a[v]._min2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&gt;p[j+1]) swap(p[j],p[j+1]); /*for (i=1;i&lt;=4;i++) printf("%d ",p[i]); puts("");*/ a[u]._min1=p[1]; a[u]._min2=p[2];/* p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[u]._min1; p[4]=a[u]._min2; p[5]=a[v]._max1; p[6]=a[v]._max2; p[7]=a[v]._min1; p[8]=a[v]._min2; sort(p+1,p+9); a[u]._max1=p[1]; a[u]._max2=p[2]; a[u]._min1=p[8]; a[u]._min2=p[7];*/&#125;void dfs(int u)&#123; int i,v; ll tmp=0; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; dfs(v); a[u].siz+=a[v].siz; tmp+=(a[v].siz+0ll)*(a[v].siz+0ll); cmp(u,v); &#125; ans[a[u].len].sum+=((a[u].siz+0ll)*(a[u].siz+0ll)-tmp)/2ll; ans[a[u].len].val=max(ans[a[u].len].val,max((a[u]._max1*a[u]._max2),(a[u]._min1*a[u]._min2))); /*if (ans[a[u].len].val==64) &#123; printf("u=%d,a[u].len=%d,a[u]._max1=%d,a[u]._max2=%d,a[u]._min1=%d,a[u]._min2=%d,",u,a[u].len,a[u]._max1,a[u]._max2,a[u]._min1,a[u]._min2); puts(""); &#125;*/&#125;void add(int u,int v)&#123; edge[++cnt]=(data)&#123;head[u],v&#125;; head[u]=cnt;&#125;int main()&#123; int i,j; scanf("%d%s",&amp;n,s+1); for (i=1;i&lt;=n;i++) b[i]=read(); rt=tp=++tot; for (i=n;i&gt;=1;i--) &#123; tp=ins(tp,i,s[i]-'a'+1); ans[i].val=-inf; &#125; for (i=2;i&lt;=tot;i++) add(a[i].fa,i); dfs(rt); for (i=n-2;i&gt;=0;i--) ans[i].sum+=ans[i+1].sum; for (i=n-1;i&gt;=0;i--) &#123; if (ans[i].sum==0) ans[i].val=0; if (i&lt;=n-2&amp;&amp;ans[i+1].sum) ans[i].val=max(ans[i].val,ans[i+1].val); &#125; for (i=0;i&lt;=n-1;i++) printf("%lld %lld\n",ans[i].sum,ans[i].val); return 0;&#125; 第二次： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300010;typedef long long ll;int n,m,tot,cnt,tp,rt,head[maxn&lt;&lt;1];ll b[maxn];const ll inf=1001;char s[maxn];struct node&#123; int fa,p,len,siz; ll _min1,_max1,_min2,_max2; int trans[27];&#125;a[maxn&lt;&lt;1];struct data&#123; int nxt,to;&#125;edge[maxn&lt;&lt;1];struct result&#123; ll sum,val;&#125;ans[maxn];#define min(a,b) (a&lt;b?a:b)#define max(a,b) (a&gt;b?a:b)#define isdigit(c) (c&gt;=48&amp;&amp;c&lt;=57)#define swap(a,b) (a^=b^=a^=b)ll read()&#123; ll x=0,f=1; char c=getchar(); while (!isdigit(c)) f=c=='-'?-1:1,c=getchar(); while (isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*f;&#125;int ins(int u,int p,int c)&#123; int x=++tot,v; a[x].len=a[u].len+1; a[x].p=p; a[x].siz=1; a[x]._min1=a[x]._max1=b[p]; a[x]._min2=inf; a[x]._max2=-inf; for (;u&amp;&amp;!a[u].trans[c];a[u].trans[c]=x,u=a[u].fa); if (!u) a[x].fa=rt; else &#123; v=a[u].trans[c]; if (a[v].len==a[u].len+1) a[x].fa=v; else &#123; int w=++tot; a[w]=a[v]; a[w].len=a[u].len+1; a[w]._max1=a[w]._max2=-inf; a[w]._min1=a[w]._min2=inf; a[w].siz=0; a[v].fa=a[x].fa=w; for (;u&amp;&amp;a[u].trans[c]==v;a[u].trans[c]=w,u=a[u].fa); &#125; &#125; return x;&#125;void cmp(int u,int v)&#123; int i,j; ll p[10]; memset(p,0,sizeof(p)); p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[v]._max1; p[4]=a[v]._max2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&lt;p[j+1]) swap(p[j],p[j+1]);/* for (i=1;i&lt;=4;i++) printf("%d ",p[i]);*/ a[u]._max1=p[1]; a[u]._max2=p[2]; memset(p,0,sizeof(p)); p[1]=a[u]._min1; p[2]=a[u]._min2; p[3]=a[v]._min1; p[4]=a[v]._min2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&gt;p[j+1]) swap(p[j],p[j+1]); /*for (i=1;i&lt;=4;i++) printf("%d ",p[i]); puts("");*/ a[u]._min1=p[1]; a[u]._min2=p[2];/* p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[u]._min1; p[4]=a[u]._min2; p[5]=a[v]._max1; p[6]=a[v]._max2; p[7]=a[v]._min1; p[8]=a[v]._min2; sort(p+1,p+9); a[u]._max1=p[1]; a[u]._max2=p[2]; a[u]._min1=p[8]; a[u]._min2=p[7];*/&#125;void dfs(int u)&#123; int i,v; ll tmp=0; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; dfs(v); a[u].siz+=a[v].siz; tmp+=(a[v].siz+0ll)*(a[v].siz+0ll); cmp(u,v); &#125; ans[a[u].len].sum+=((a[u].siz+0ll)*(a[u].siz+0ll)-tmp)/2ll; ans[a[u].len].val=max(ans[a[u].len].val,max((a[u]._max1*a[u]._max2),(a[u]._min1*a[u]._min2))); /*if (ans[a[u].len].val==64) &#123; printf("u=%d,a[u].len=%d,a[u]._max1=%d,a[u]._max2=%d,a[u]._min1=%d,a[u]._min2=%d,",u,a[u].len,a[u]._max1,a[u]._max2,a[u]._min1,a[u]._min2); puts(""); &#125;*/&#125;void add(int u,int v)&#123; edge[++cnt]=(data)&#123;head[u],v&#125;; head[u]=cnt;&#125;int main()&#123; int i,j; scanf("%d%s",&amp;n,s+1); for (i=1;i&lt;=n;i++) b[i]=read(); rt=tp=++tot; for (i=n;i&gt;=1;i--) &#123; tp=ins(tp,i,s[i]-'a'+1); ans[i].val=-inf; &#125; for (i=2;i&lt;=tot;i++) add(a[i].fa,i); dfs(rt); for (i=n-2;i&gt;=0;i--) ans[i].sum+=ans[i+1].sum; for (i=n-1;i&gt;=0;i--) &#123; if (ans[i].sum==0) ans[i].val=0; if (i&lt;=n-2&amp;&amp;ans[i+1].sum) ans[i].val=max(ans[i].val,ans[i+1].val); &#125; for (i=0;i&lt;=n-1;i++) printf("%lld %lld\n",ans[i].sum,ans[i].val); return 0;&#125; 第三次： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300010;typedef long long ll;int n,m,tot,cnt,tp,rt,head[maxn&lt;&lt;1];ll b[maxn];const ll inf=1000000007;char s[maxn];struct node&#123; int fa,p,len,siz; ll _min1,_max1,_min2,_max2; int trans[27];&#125;a[maxn&lt;&lt;1];struct data&#123; int nxt,to;&#125;edge[maxn&lt;&lt;1];struct result&#123; ll sum,val;&#125;ans[maxn];#define min(a,b) (a&lt;b?a:b)#define max(a,b) (a&gt;b?a:b)#define isdigit(c) (c&gt;=48&amp;&amp;c&lt;=57)#define swap(a,b) (a^=b^=a^=b)ll read()&#123; ll x=0,f=1; char c=getchar(); while (!isdigit(c)) f=c=='-'?-1:1,c=getchar(); while (isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*f;&#125;int ins(int u,int p,int c)&#123; int x=++tot,v; a[x].len=a[u].len+1; a[x].p=p; a[x].siz=1; a[x]._min1=a[x]._max1=b[p]; a[x]._min2=inf; a[x]._max2=-inf; for (;u&amp;&amp;!a[u].trans[c];a[u].trans[c]=x,u=a[u].fa); if (!u) a[x].fa=rt; else &#123; v=a[u].trans[c]; if (a[v].len==a[u].len+1) a[x].fa=v; else &#123; int w=++tot; a[w]=a[v]; a[w].len=a[u].len+1; a[w]._max1=a[w]._max2=-inf; a[w]._min1=a[w]._min2=inf; a[w].siz=0; a[v].fa=a[x].fa=w; for (;u&amp;&amp;a[u].trans[c]==v;a[u].trans[c]=w,u=a[u].fa); &#125; &#125; return x;&#125;void cmp(int u,int v)&#123; int i,j; ll p[10]; memset(p,0,sizeof(p)); p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[v]._max1; p[4]=a[v]._max2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&lt;p[j+1]) swap(p[j],p[j+1]);/* for (i=1;i&lt;=4;i++) printf("%d ",p[i]);*/ a[u]._max1=p[1]; a[u]._max2=p[2]; memset(p,0,sizeof(p)); p[1]=a[u]._min1; p[2]=a[u]._min2; p[3]=a[v]._min1; p[4]=a[v]._min2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&gt;p[j+1]) swap(p[j],p[j+1]); /*for (i=1;i&lt;=4;i++) printf("%d ",p[i]); puts("");*/ a[u]._min1=p[1]; a[u]._min2=p[2];/* p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[u]._min1; p[4]=a[u]._min2; p[5]=a[v]._max1; p[6]=a[v]._max2; p[7]=a[v]._min1; p[8]=a[v]._min2; sort(p+1,p+9); a[u]._max1=p[1]; a[u]._max2=p[2]; a[u]._min1=p[8]; a[u]._min2=p[7];*/&#125;void dfs(int u)&#123; int i,v; ll tmp=0; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; dfs(v); a[u].siz+=a[v].siz; tmp+=(a[v].siz+0ll)*(a[v].siz+0ll); cmp(u,v); &#125; if (a[u].siz&lt;2) return; ans[a[u].len].sum+=((a[u].siz+0ll)*(a[u].siz+0ll)-tmp)/2ll; ans[a[u].len].val=max(ans[a[u].len].val,max((a[u]._max1*a[u]._max2),(a[u]._min1*a[u]._min2))); /*if (ans[a[u].len].val==64) &#123; printf("u=%d,a[u].len=%d,a[u]._max1=%d,a[u]._max2=%d,a[u]._min1=%d,a[u]._min2=%d,",u,a[u].len,a[u]._max1,a[u]._max2,a[u]._min1,a[u]._min2); puts(""); &#125;*/&#125;void add(int u,int v)&#123; edge[++cnt]=(data)&#123;head[u],v&#125;; head[u]=cnt;&#125;int main()&#123;// freopen("testdata(1).in","r",stdin);// freopen("testdata(1).txt","w",stdout); int i,j; scanf("%d%s",&amp;n,s+1);// puts(s+1); for (i=1;i&lt;=n;i++) b[i]=read();// scanf("%lld",&amp;b[i]); rt=tp=++tot; for (i=n;i&gt;=1;i--) &#123; tp=ins(tp,i,s[i]-'a'+1); ans[i].val=-(inf*inf); &#125; for (i=2;i&lt;=tot;i++) add(a[i].fa,i); a[rt]._min1=a[rt]._min2=inf; a[rt]._max1=a[rt]._max2=-inf; dfs(rt);/* for (i=n-2;i&gt;=0;i--) ans[i].sum+=ans[i+1].sum;*/ for (i=n-1;i&gt;=0;i--) &#123; if (ans[i].sum==0) ans[i].val=0; if (i&lt;=n-2&amp;&amp;ans[i+1].sum) ans[i].val=max(ans[i].val,ans[i+1].val); ans[i].sum+=ans[i+1].sum; ans[i].val=max(ans[i].val,ans[i+1].val); &#125; for (i=0;i&lt;=n-1;i++) printf("%lld %lld\n",ans[i].sum,ans[i].val); return 0;&#125; 第四次： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=300010;typedef long long ll;int n,m,tot,cnt,tp,rt,head[maxn&lt;&lt;1];//注意节点数会变成2n，所以存树的时候也一定要开这么大的空间ll b[maxn];//这个是题目中给出的a[i]const ll inf=1000000007;//事实证明INF要开到比1e9大才可以char s[maxn];struct node&#123; int fa,p,len,siz;//父亲，当前位置，后缀长度，子树大小 ll _min1,_max1,_min2,_max2;//最小，最大，次小，次大 int trans[27];&#125;a[maxn&lt;&lt;1];struct data&#123; int nxt,to;&#125;edge[maxn&lt;&lt;1];//存树，边只用开2n就够了，因为只需要用单向边来存父亲到儿子就好了struct result&#123; ll sum,val;//后缀节点的对数，最大值&#125;ans[maxn];//记录答案#define min(a,b) (a&lt;b?a:b)//最小#define max(a,b) (a&gt;b?a:b)//最大#define isdigit(c) (c&gt;=48&amp;&amp;c&lt;=57)//判断是否是数字，用于读入优化#define swap(a,b) (a^=b^=a^=b)//交换ll read()&#123; ll x=0,f=1; char c=getchar(); while (!isdigit(c)) f=c=='-'?-1:1,c=getchar(); while (isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*f;&#125;int ins(int u,int p,int c)//建后缀树&#123; int x=++tot,v; a[x].len=a[u].len+1; a[x].p=p; a[x].siz=1;//这一定是后缀点 a[x]._min1=a[x]._max1=b[p];//注意最小最大赋值成a[i] a[x]._min2=inf;//其余赋值成正负无穷 a[x]._max2=-inf; for (;u&amp;&amp;!a[u].trans[c];a[u].trans[c]=x,u=a[u].fa); if (!u) a[x].fa=rt; else &#123; v=a[u].trans[c]; if (a[v].len==a[u].len+1) a[x].fa=v; else &#123; int w=++tot; a[w]=a[v]; a[w].len=a[u].len+1; a[w]._max1=a[w]._max2=-inf;//分裂点没有权值，只能被别人更新，所以初始为正负无穷 a[w]._min1=a[w]._min2=inf; a[w].siz=0;//分裂点一定不是后缀点 a[v].fa=a[x].fa=w; for (;u&amp;&amp;a[u].trans[c]==v;a[u].trans[c]=w,u=a[u].fa); &#125; &#125; return x;&#125;void cmp(int u,int v)//用来更新最大最小次大次小值，u是父亲，v是儿子&#123; int i,j; ll p[10]; memset(p,0,sizeof(p)); p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[v]._max1; p[4]=a[v]._max2; for (i=1;i&lt;=3;i++)//冒泡 for (j=1;j&lt;=4-i;j++) if (p[j]&lt;p[j+1]) swap(p[j],p[j+1]);/* for (i=1;i&lt;=4;i++) printf("%d ",p[i]);*/ a[u]._max1=p[1]; a[u]._max2=p[2]; memset(p,0,sizeof(p)); p[1]=a[u]._min1; p[2]=a[u]._min2; p[3]=a[v]._min1; p[4]=a[v]._min2; for (i=1;i&lt;=3;i++) for (j=1;j&lt;=4-i;j++) if (p[j]&gt;p[j+1]) swap(p[j],p[j+1]); /*for (i=1;i&lt;=4;i++) printf("%d ",p[i]); puts("");*/ a[u]._min1=p[1]; a[u]._min2=p[2];/* p[1]=a[u]._max1; p[2]=a[u]._max2; p[3]=a[u]._min1; p[4]=a[u]._min2; p[5]=a[v]._max1; p[6]=a[v]._max2; p[7]=a[v]._min1; p[8]=a[v]._min2; sort(p+1,p+9); a[u]._max1=p[1]; a[u]._max2=p[2]; a[u]._min1=p[8]; a[u]._min2=p[7];*/&#125;void dfs(int u)//树形DP统计答案&#123; int i,v; ll tmp=0;//tmp是每个子树的节点个数的平方之和 for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; dfs(v); a[u].siz+=a[v].siz;//加上子树大小// size+=a[v].siz; tmp+=(a[v].siz+0ll)*(a[v].siz+0ll);//记录平方和 cmp(u,v);//统计最大最小值 &#125; if (a[u].siz&lt;2)//构不成LCP就返回 return; ans[a[u].len].sum+=((a[u].siz+0ll)*(a[u].siz+0ll)-tmp)/2ll;//记录有多少点对// ans[a[u].len].sum+=((a[u].siz+size+0ll)*(a[u].siz+size+0ll)-tmp)/2ll;// a[u].siz+=size; ans[a[u].len].val=max(ans[a[u].len].val,max((a[u]._max1*a[u]._max2),(a[u]._min1*a[u]._min2)));//记录此处的乘积最大值 /*if (ans[a[u].len].val==64) &#123; printf("u=%d,a[u].len=%d,a[u]._max1=%d,a[u]._max2=%d,a[u]._min1=%d,a[u]._min2=%d,",u,a[u].len,a[u]._max1,a[u]._max2,a[u]._min1,a[u]._min2); puts(""); &#125;*/&#125;void add(int u,int v)//把树形结构建立起来&#123; edge[++cnt]=(data)&#123;head[u],v&#125;; head[u]=cnt;&#125;int main()&#123;/* freopen("testdata (2).in","r",stdin); freopen("testdata (2).txt","w",stdout);*/ int i,j; scanf("%d%s",&amp;n,s+1);// puts(s+1); for (i=1;i&lt;=n;i++) b[i]=read();// scanf("%lld",&amp;b[i]); rt=tp=++tot; for (i=n;i&gt;=1;i--) &#123; tp=ins(tp,i,s[i]-'a'+1); ans[i].val=-(inf*inf);//初始化每个节点，注意是要INF的平方才行（因为这个是乘积） &#125; for (i=2;i&lt;=tot;i++) add(a[i].fa,i);//建边 a[rt]._min1=a[rt]._min2=inf; a[rt]._max1=a[rt]._max2=-inf; //根节点要更新 dfs(rt);//树形DP /*for (i=n-2;i&gt;=0;i--) ans[i].sum+=ans[i+1].sum;*/ for (i=n-1;i&gt;=0;i--)//统计后缀和、后缀最大值 &#123; if (ans[i].sum==0)//如果当前为0，那么全都为0 ans[i].val=0; if (i&lt;=n-2&amp;&amp;ans[i+1].sum!=0)//上一个不为0，可以用来更新 ans[i].val=max(ans[i].val,ans[i+1].val); ans[i].sum+=ans[i+1].sum;//更新和// ans[i].val=max(ans[i].val,ans[i+1].val); &#125; for (i=0;i&lt;=n-1;i++) printf("%lld %lld\n",ans[i].sum,ans[i].val); return 0;&#125; 然后我又交到的UOJ上，发现被人Hack掉了。 12345678in：2aa1000000000 -1000000000 out：1 -10000000000000000001 -1000000000000000000 这样的数据可以慢慢调，总能搞好的。 总结：这是我人生第一道洛谷黑题啊！ 虽然用了一天去写，但也感觉很值得。 思路很有趣，很多的实现细节也很有价值。]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
        <tag>树形DP</tag>
        <tag>后缀树</tag>
        <tag>细节</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P3804】【模板】后缀自动机]]></title>
    <url>%2F2019%2F04%2F18%2F%E3%80%90%E6%B4%9B%E8%B0%B7P3804%E3%80%91%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【UOJ#35】后缀排序]]></title>
    <url>%2F2019%2F04%2F18%2F%E3%80%90UOJ-35%E3%80%91%E5%90%8E%E7%BC%80%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性筛总结]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组总结]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <tags>
        <tag>坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4034】【HAOI2015】树上操作]]></title>
    <url>%2F2019%2F04%2F16%2F%E3%80%90BZOJ4034%E3%80%91%E3%80%90HAOI2015%E3%80%91%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题解知识点：树链剖分，线段树 分析：这是一道非常简单的树剖模板（真正有难度的模板是LOJ上那道题）。其实操作一和二可以合并成同一个操作（都是区间加），然后对链的情况进行查找，就结束了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include&lt;cstdio&gt;using namespace std;const int maxn=100010;typedef long long ll;int n,m,tot,head[maxn],fa[maxn],dep[maxn],siz[maxn],son[maxn],id[maxn],top[maxn],cnt;ll a[maxn],key[maxn],ans;struct node&#123; int nxt,to;&#125;edge[maxn&lt;&lt;1];struct data&#123; ll val,tag;&#125;t[maxn&lt;&lt;2];#define ls (o&lt;&lt;1)#define rs (o&lt;&lt;1|1)#define mid (l+r&gt;&gt;1)#define isdigit(c) (c&gt;=48&amp;&amp;c&lt;=57)#define swap(a,b) (a^=b^=a^=b)int read()&#123; int x=0,f=1; char c=getchar(); while (!isdigit(c)) f=c=='-'?-1:1,c=getchar(); while (isdigit(c)) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*f;&#125;void dfs1(int u,int fat)&#123; dep[u]=dep[fat]+1; fa[u]=fat; siz[u]=1; int i,v; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; if (v==fat) continue; dfs1(v,u); siz[u]+=siz[v];//一开始漏写了这行导致找不出哪里错 if (siz[v]&gt;siz[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; top[u]=tp; id[u]=++cnt; key[cnt]=a[u]; if (!son[u]) return; dfs2(son[u],tp); int i,v; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; if (v==fa[u]||v==son[u]) continue; dfs2(v,v); &#125;&#125;void pushdown(int o,int l,int r)&#123; if (t[o].tag) &#123; t[ls].tag+=t[o].tag; t[rs].tag+=t[o].tag; t[ls].val+=(mid-l+1)*t[o].tag; t[rs].val+=(r-mid)*t[o].tag; t[o].tag=0; &#125;&#125;void build(int o,int l,int r)&#123; if (l==r) &#123; t[o].val=key[l]; return; &#125; build(ls,l,mid); build(rs,mid+1,r); t[o].val=t[ls].val+t[rs].val;&#125;void update(int o,int l,int r,int x,int y,ll val)&#123; if (l&gt;y||r&lt;x) return; if (x&lt;=l&amp;&amp;r&lt;=y) &#123; t[o].val+=(r-l+1)*val; t[o].tag+=val; return; &#125; pushdown(o,l,r); update(ls,l,mid,x,y,val); update(rs,mid+1,r,x,y,val); t[o].val=t[ls].val+t[rs].val;&#125;ll query(int o,int l,int r,int x,int y)&#123; if (l&gt;y||r&lt;x) return 0; if (x&lt;=l&amp;&amp;r&lt;=y) return t[o].val; pushdown(o,l,r); return query(ls,l,mid,x,y)+query(rs,mid+1,r,x,y);&#125;void add(int u,int v)&#123; edge[++tot]=(node)&#123;head[u],v&#125;; head[u]=tot;&#125;int main()&#123; int i,j,u,v; n=read(); m=read(); for (i=1;i&lt;=n;i++) a[i]=read(); for (i=1;i&lt;=n-1;i++) &#123; u=read(); v=read(); add(u,v); add(v,u); &#125; dfs1(1,0); dfs2(1,1); build(1,1,n); while (m--) &#123; i=read(); u=read(); if (i==1) &#123; v=read(); update(1,1,n,id[u],id[u],v+0ll); &#125; else if (i==2) &#123; v=read(); update(1,1,n,id[u],id[u]+siz[u]-1,v+0ll); &#125; else &#123; v=1; ans=0; while (top[u]!=top[v]) &#123; if (dep[top[u]]&lt;dep[top[v]]) swap(u,v); ans+=query(1,1,n,id[top[u]],id[u]); u=fa[top[u]]; &#125; if (dep[u]&gt;dep[v]) swap(u,v); ans+=query(1,1,n,id[u],id[v]); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>树链剖分</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1968】【AHOI2005】COMMON约数研究]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90BZOJ1968%E3%80%91%E3%80%90AHOI2005%E3%80%91COMMON%E7%BA%A6%E6%95%B0%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[题解知识点：数学，线性筛，约数个数定理 分析：由正整数唯一分解定理 $N=\displaystyle\prod_{i=1}^{k}{p_{i}^{r_i}}$可以知道，所有的质因子及其次数都是确定的。 又有约数个数定理：$d(n)=\displaystyle\prod_{i=1}^{k}1+r_i$ 所以只要套用模板就可以解决问题了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1000010;int n,m,pr[maxn],num[maxn],d[maxn];long long ans;bool v[maxn];int main()&#123; int i,j; scanf("%d",&amp;n); v[1]=0; num[1]=1; d[1]=1; for (i=2;i&lt;=n;i++) &#123; if (!v[i]) &#123; pr[++m]=i; d[i]=2; num[i]=1; &#125; for (j=1;j&lt;=m&amp;&amp;pr[j]*i&lt;=n;j++) &#123; v[i*pr[j]]=1; if (i%pr[j]==0) &#123; d[i*pr[j]]=d[i]/(num[i]+1)*(num[i]+2); num[i*pr[j]]=num[i]+1; break; &#125; else &#123; d[i*pr[j]]=d[i]*2;//d[i*pr[j]]=d[i]*d[pr[j]]; num[i*pr[j]]=1; &#125; &#125; &#125; for (i=1;i&lt;=n;i++) ans+=d[i]+0ll; printf("%lld\n",ans); return 0;&#125; 先留一个坑，要写线性筛五连（素数，约数个数，约数和，欧拉函数，莫比乌斯函数）的总结。]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>线性筛</tag>
        <tag>数论</tag>
        <tag>约数个数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P3800】Power收集]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90%E6%B4%9B%E8%B0%B7P3800%E3%80%91Power%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题解知识点：DP，方格类最优值DP，单调队列优化DP 分析：相信这道题大家都知道肯定是DP，然而非常简单地想到，从上一层的每个点枚举走到这个点的最大值。 一开始看到这个数据范围我就觉得可以硬做，但是又想到这样的裸的DP是$O(n^3)$的，不能通过所有的测试点。然后我想到了单调队列优化DP，可以优化到$O(n^2)$，当然这样是正确的解法，但是我又觉得细节有点多，还不如我写一个带log的数据结构去优化DP，然后我就写了一棵线段树维护区间最大值，但是常数太大还是TLE了最后一个点，用ST表写反而WA了8个点。最后不得不再次观察数据范围。 发现其实k的值非常小（与n同阶）。所以考虑先把所有有值的点按照x轴来排序（从上往下），然后进行DP。枚举之前行的点，因为每一行跳t步的话，x行最多可以跳xt步，那么判断$\Delta y$与$\Delta x\times t$之间的关系，如果前者不大于后者，那么代表走得到，就可以转移。这样求最大值，复杂度是$O(n^2)$的，而且常数很小，值得推荐。 代码：123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;//#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=4010;int n,m,k,t,f[maxn],ans;struct node&#123; int x,y,v;&#125;a[maxn];bool cmp(node a,node b)&#123; return a.x&lt;b.x;&#125;int main()&#123; int i,j; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;t); for (i=1;i&lt;=k;i++) scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].v); sort(a+1,a+k+1,cmp);//排序 f[1]=a[1].v;//初始值即为取走它自己的值 for (i=1;i&lt;=k;i++) &#123; for (j=0;j&lt;i;j++) if (abs(a[i].y-a[j].y)&lt;=t*abs(a[i].x-a[j].x))//走不走得到 f[i]=max(f[i],f[j]+a[i].v);//走得到就转移 ans=max(ans,f[i]);//在过程中就可以求最大值了（因为v有可能是非正数） &#125; printf("%d\n",ans); return 0;&#125; 从这道题，我们可以发现，当一些题目n不小的时候，可以观察其他约束条件，从简单的问题入手，往往可以收获更好的结果。]]></content>
      <categories>
        <category>题目总结</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ5141】【Usaco2017 DEC】Barn Painting]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90BZOJ5141%E3%80%91%E3%80%90Usaco2017-DEC%E3%80%91Barn-Painting%2F</url>
    <content type="text"><![CDATA[题解：知识点：树形DP，计数类DP问题 分析：非常简单，走到一个点先初始化成1（假如有规定的颜色的点除外），然后往子节点走，一直走到没有，返回，合并答案。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;using namespace std;const int maxn=100010;int n,tot,head[maxn],a[maxn],k;typedef long long ll;ll f[maxn][4];const ll mod=1000000007;struct node&#123; int nxt,to;&#125;edge[maxn&lt;&lt;1];int read()&#123; int x=0,ff=1; char c=getchar(); while (c&lt;48||c&gt;57) ff=c=='-'?-1:1,c=getchar(); while (c&gt;=48&amp;&amp;c&lt;=57) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x*ff;&#125;void dp(int u,int fa)&#123; int i,v,p=0; f[u][1]=f[u][2]=f[u][3]=1; if (a[u]) &#123; f[u][1]=f[u][2]=f[u][3]=0; f[u][a[u]]=1; &#125; for (i=head[u];i;i=edge[i].nxt) &#123; v=edge[i].to; if (v==fa) continue; dp(v,u); p=1; if (a[u]==0) &#123;//注意这里是先+后* f[u][1]=(f[u][1]*(f[v][2]+f[v][3])%mod)%mod; f[u][2]=(f[u][2]*(f[v][1]+f[v][3])%mod)%mod; f[u][3]=(f[u][3]*(f[v][1]+f[v][2])%mod)%mod; &#125; else f[u][a[u]]=(f[u][a[u]]*(f[v][1]+f[v][2]+f[v][3]-f[v][a[u]])%mod+mod)%mod; &#125;&#125;void add(int u,int v)&#123; edge[++tot]=(node)&#123;head[u],v&#125;; head[u]=tot;&#125;int main()&#123; int i,j,u,v; n=read(); k=read(); for (i=1;i&lt;=n-1;i++) &#123; u=read(); v=read(); add(u,v); add(v,u); &#125; for (i=1;i&lt;=k;i++) &#123; u=read(); v=read(); a[u]=v; &#125; dp(1,0); printf("%lld\n",(f[1][1]+f[1][2]+f[1][3])%mod); return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>DP</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4566】【HAOI2016】找相同字符]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90BZOJ4566%E3%80%91%E3%80%90HAOI2016%E3%80%91%E6%89%BE%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[题解知识点：后缀数组，LCP，单调栈 分析：要求两个串的子串相同的个数，在两个串上不是很好求。所以我们转换成一个串，把两个串连接成一个字符串，我们要求两个串的后缀的前缀相同的个数（而且这两个位置必须得来自两个不同的串，当然这个只是一个简单的判断而已）。 把串连接起来之后，做两遍单调栈，分别枚举前面的对后面的做的贡献。而两遍单调栈分别以A串和B串作为主元（哪个为主，前缀和贡献的时候就算哪一个，而在代码中的贡献判断就算另一个）。 这样整个过程的时间复杂度是$O(n\log_{2}n)$的。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=400010;int n,m,sa[maxn],rnk[maxn],y[maxn],height[maxn],pos,c[maxn],len,sum[maxn];typedef long long ll;ll ans,tmp;struct node&#123; int x,ht;&#125;st[maxn];char s[maxn];void srt()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; m=122; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]-96; y[i]=i; &#125; srt(); for (k=1;p&lt;n;k&lt;&lt;=1,m=p) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; srt(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,j,k=0; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[i+k]==s[j+k]) k++; height[rnk[i]]=k; &#125;&#125;int main()&#123; int i,j; scanf("%s",s+1); len=strlen(s+1); s[len+1]='z'+1;//放一个一定最大的不在字符集中的字符，不会影响整个串 scanf("%s",s+len+2); n=strlen(s+1); getsa(); getheight(); st[pos]=(node)&#123;1,0&#125;; for (i=1;i&lt;=n;i++) sum[i]+=sum[i-1]+(sa[i]&lt;=len);//前缀和贡献的个数 for (i=1;i&lt;=n;i++) &#123; while (height[i]&lt;height[st[pos].x]&amp;&amp;pos) pos--; st[++pos]=(node)&#123;i,(sum[i-1]-sum[st[pos-1].x-1])*height[i]+st[pos-1].ht&#125;;//贡献 if (sa[i]&gt;len+1) ans+=st[pos].ht; &#125; pos=0; memset(sum,0,sizeof(sum));//与上面的过程同理 for (i=1;i&lt;=n;i++) sum[i]+=sum[i-1]+(sa[i]&gt;len+1); for (i=1;i&lt;=n;i++) &#123; while (height[i]&lt;height[st[pos].x]&amp;&amp;pos) pos--; st[++pos]=(node)&#123;i,(sum[i-1]-sum[st[pos-1].x-1])*height[i]+st[pos-1].ht&#125;; if (sa[i]&lt;=len) ans+=st[pos].ht; &#125; printf("%lld\n",ans); return 0;&#125; 顺便讲一讲罗穗骞的论文中讲到的眼神问题，如果规定要求的答案是两个串的长度大于等于$k$的子串的个数，那么在单调栈前还要做一些改动，就是将height值按照能不能大于等于$k$进行分组，分完组之后，贡献就只能在组内算，不能算外面的（因为那些长度都不够）。详情见论文。]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3238】【AHOI2013】差异]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90BZOJ3238%E3%80%91%E3%80%90AHOI2013%E3%80%91%E5%B7%AE%E5%BC%82%2F</url>
    <content type="text"><![CDATA[Description Input一行，一个字符串S Output一行，一个整数，表示所求值 Sample Inputcacao Sample Output 54 HINT2&lt;=N&lt;=500000,S由小写英文字母组成 题解知识点：后缀数组，单调栈，LCP 分析：先推一推式子，看看有没有机会化简： $$\begin{aligned}ans&amp;=\displaystyle\sum_{1\leq i&lt;j\leq n}len(T_{i})+len(T_{j})-2\times lcp(T_{i},T_{j})\&amp;=(\displaystyle\sum_{i=1}^{n-1}{\displaystyle\sum_{j=i+1}^{n}{i+j}})-(\displaystyle\sum_{1\leq i&lt;j\leq n}2\times lcp(T_{i},T_{j}))\&amp;=((n-1)\times\displaystyle\sum_{i=1}^n{i})-(\displaystyle\sum_{1\leq i&lt;j\leq n}2\times lcp(T_{i},T_{j}))\&amp;=\frac{(n-1)\times n\times (n+1)}{2}-\displaystyle\sum_{1\leq i&lt;j\leq n}2\times lcp(T_{i},T_{j})\end{aligned}$$我们可以发现式子的前半部分经过推算是一个常数项，非常容易处理，所以我们只用关注后半部分的内容即可。 后面的式子意义其实是所有的后缀两两组合的LCP。假如我们正着求解这个内容，时间复杂度是$O(n^2)​$的，会超时。考虑反着计算，求两两之间的LCP，不如求每个LCP对答案的贡献有多少（因为其实LCP的值会重复出现很多次，所以这样计算非常高效）。通过性质可以知道，LCP（i，j）是等于他们之间的height值的最小值。可以通过这个性质，考虑维护一个线性的数据结构，算出每个height值最多向左和向右延伸多长（延伸的范围就是它的贡献区间，它在那一段上面都是最小值，LCP必定是它）。 那么我们现在着手思考如何快速求出左右延伸的最长距离。经查阅大体有两种不同的方法。然而我当时自己只想出了方法一（相对好理解）。 方法一：用一个单调栈维护向左最多能够走多远（遇到相等的可以先留下来，最后处理），这个栈是从栈底到栈顶非严格单调递增的，记录每个点的$l[i]$。同理，对向右最多能够走多远也同样地维护一次，记录下$r[i]$。最后每个点算上从$l[i]$到$i$和从$r[i]$到$i$一共有多少个贡献区间。由乘法原理可以知道，区间的个数应该是$(i-l[i]+1)\times(r[i]-i+1)$。这个就是每个位置的答案。累加起来就完成了，这里的时间复杂度是$O(n)$，常数也很小。 方法二：同样地用单调栈维护从左往右的最小值，然后在里面DP，DP记录往左数第一个小于等于当前位置height值的位置到现在这一位的贡献是多少，把贡献累加，计算答案。这里的时间复杂度也是$O(n)$，但是常数比方法一要大。 综上所述，总的来说就是先推完式子，把前一半变成一个常数，把后一半用后缀数组求出来，单调栈维护每个height值对所有区间的贡献。总体时间复杂度是$O(n\log_{2}n)$。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=500010;int n,m=122,sa[maxn],rnk[maxn],height[maxn],y[maxn],c[maxn],pos,st[maxn],l[maxn],r[maxn];long long ans,f[maxn];char s[maxn];void srt()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]-96; y[i]=i; &#125; srt(); for (k=1;p&lt;n;m=p,k&lt;&lt;=1) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; srt(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,j,k=0; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[i+k]==s[j+k]) k++; height[rnk[i]]=k; &#125;&#125;void solve1()&#123; int i; pos=0; st[pos]=0; height[st[pos]]=-(n+10);//预处理栈底 for (i=1;i&lt;=n;i++) &#123; while (height[i]&lt;height[st[pos]]) pos--; if (st[pos]==0) l[i]=1; else l[i]=st[pos]+1; st[++pos]=i; &#125; pos=0; st[pos]=n+1; height[st[pos]]=-(n+10);//同L67 for (i=n;i&gt;=1;i--) &#123; while (height[i]&lt;=height[st[pos]]) pos--; if (st[pos]==n+1) r[i]=n; else r[i]=st[pos]-1; st[++pos]=i; &#125; ans=1ll*(n-1)*n*(n+1)/2; for (i=1;i&lt;=n;i++) ans-=2ll*(i-l[i]+1)*(r[i]-i+1)*height[i];&#125;void solve2()&#123; int i,j; height[n+1]=0; for (i=1;i&lt;=n;i++) &#123; while (height[i]&lt;height[st[pos]]) pos--; j=st[pos]; f[i]=f[j]+(i-j)*height[i];//DP ans-=2ll*f[i]; st[++pos]=i; &#125; ans+=1ll*(n-1)*n*(n+1)/2;&#125;int main()&#123; int i,j; scanf("%s",s+1); n=strlen(s+1); getsa(); getheight(); solve1();// solve2(); printf("%lld\n",ans); return 0;&#125; 通过这道题，我们可以看出一般的后缀数组的题目，都可以巧妙地利用单调栈和height数组的性质来解决问题（特别是对于字符串的LCP最大最小这类问题，而且明显模拟地去求会TLE的时候，可以考虑反着求贡献）。 正所谓正难则反！]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【洛谷P2408】不同子串个数 以及此类问题的拓展]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90%E6%B4%9B%E8%B0%B7P2408%E3%80%91%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目背景因为NOI被虐傻了，蒟蒻的YJQ准备来学习一下字符串，于是它碰到了这样一道题： 题目描述给你一个长为$N$的字符串，求不同的子串的个数。 我们定义两个子串不同，当且仅当有这两个子串长度不一样 或者长度一样且有任意一位不一样。 子串的定义：原字符串中连续的一段字符组成的字符串。 输入输出格式输入格式：第一行一个整数$N$。 接下来一行$N$个字符表示给出的字符串。 输出格式：一行一个整数，表示不一样的子串个数。 题解：知识点：后缀数组，LCP 分析：其实求本质不同的子串的个数这类问题，很容易联想到后缀数据结构。其实可以发现子串不同相当于所有后缀的前缀不同的情况，所以我们把问题的统计变成了统计前缀的不同个数。 我们以$sa[1],sa[2],sa[3],sa[i] \cdots，sa[n]$的顺序统计每个$suffix$,可以发现每次加入的后缀的前缀的个数为$n-sa[i]+1$,但是这里面有很多是重复的，我们要把它们减掉，又$height[i]$的定义我们可以知道，既然前$i-1$处已经计算过$suffix(sa[i])的前height[i]$位了，那么我们把$height[i]$减掉就是答案了，这样就可以线性地解决问题。 时间复杂度：$O(n\log_{2}n)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=100010;int n,m=128,sa[maxn],rnk[maxn],y[maxn],height[maxn],c[maxn];char s[maxn];long long ans;//答案会很大，要开够void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]; y[i]=i; &#125; sort(); for (k=1;p&lt;n;k&lt;&lt;=1,m=p) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,j,k=0; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[j+k]==s[i+k]) k++; height[rnk[i]]=k; &#125;&#125;int main()&#123; int i; scanf("%d%s",&amp;n,s+1); getsa(); getheight(); for (i=1;i&lt;=n;i++) ans+=n-sa[i]+1-height[i]; printf("%lld\n",ans); return 0;&#125; 现在我们考虑变成多组数据，在时间复杂度允许的情况下，直接搞就好了，但是注意字符集大小每次要恢复到128，数组要清空。(Eg.SPOJ694 705) 而LZOJ里面的那道把数据组数开到了$10^{3}$，但是同时字符集变小了，这样也是可以跑过去的（常数不能太大）。]]></content>
      <categories>
        <category>题目总结</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ3261】milk patterns]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90POJ3261%E3%80%91milk-patterns%2F</url>
    <content type="text"><![CDATA[题解：知识点：后缀数组，二分，LCP，离散化 分析：按照罗穗骞的论文（《后缀数组—-处理字符串的有力工具》，IOI2009中国国家集训队论文集）中的说法，这种题型叫做: 可重叠的k 次最长重复子串 解决的方法是：先求出sa、height，然后二分长度$mid$，把一个求最大值问题转化成判定性问题。判定中，我们把height值大于等于$mid$的分组（即假如中间有一个height值小于mid，那么这个位置被分作下一组，然后再继续统计答案），假如一个组中的后缀个数大于等于$k$的话，这种情况就是成立的，然后继续缩小范围查找。 注意这道题的字符集大小太大了（虽然说数据太水了，不离散化也可以过），我们要先进行离散化，给字符重新定义一个值，然后再进行操作。 整个过程总的时间复杂度是：$O(n\log_{2}n)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20010;int n,m=20000,k,sa[maxn],a[maxn],_a[maxn],rnk[maxn],y[maxn],c[maxn],height[maxn],b[maxn],cnt;int read()&#123; int x=0,ff=1; char cc=getchar(); while (cc&lt;48||cc&gt;57) ff=cc=='-'?-1:1,cc=getchar(); while (cc&gt;=48&amp;&amp;cc&lt;=57) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(cc^48),cc=getchar(); return x*ff;&#125;void srt()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=a[i];//因为已经离散化过了，所以可以直接用 y[i]=i; &#125; srt(); for (k=1;p&lt;n;m=p,k&lt;&lt;=1) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; srt(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,k=0,j; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rnk[i]]=k; &#125;&#125;bool check(int len)&#123; int tot=1,i;//因为第一个位置虽然height为0，但是也是有一个，所以初始值为1 /*for (i=2;i&lt;=n;i++) &#123; if (height[i]&lt;len) &#123; if (tot&gt;=k) return 1; tot=1; &#125; else tot++; &#125; return 0;*/ for (i=2;i&lt;=n;i++) &#123; if (height[i]&lt;len) tot=1;//如果不满足，就新开一个组 else tot++;//否则就继续 if (tot&gt;=k)//已经成立就返回 return 1; &#125; return 0;&#125;int getnum(int x)//二分查找最接近的值，可以用stl的lower_bound来代替，不过手写常数小&#123; int l=1,r=cnt,mid; while (l&lt;=r) &#123; mid=(l+r+1)&gt;&gt;1; if (b[mid]==x) return mid; if (b[mid]&lt;x) l=mid+1; else r=mid-1; &#125;&#125;int main()&#123; int i,j; n=read(); k=read(); for (i=1;i&lt;=n;i++) a[i]=read(),_a[i]=a[i];//另开一个空间来存离散的东西 sort(_a+1,_a+n+1); for (i=1;i&lt;=n;i++) if (i==1||_a[i]!=_a[i-1]) b[++cnt]=_a[i];//去重，可以用一个stl函数代替 for (i=1;i&lt;=n;i++) a[i]=getnum(a[i]);//离散化 getsa(); getheight(); int l=1,r=n,mid; while (l&lt;r)//二分可行的长度 &#123; mid=(l+r+1)&gt;&gt;1; if (check(mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
        <tag>离散化</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LZOJ3071】后缀数组/后缀树2]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90LZOJ3071%E3%80%91%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E5%90%8E%E7%BC%80%E6%A0%912%2F</url>
    <content type="text"><![CDATA[题解知识点：后缀数组，最长公共前缀 分析：这道题是一道lcp的入门题，主要是先求出SA，然后通过SA线性求出Height，最后预处理出ST表，然后每次访问的时候调用即可。细节较多，在代码中讲解。 时间复杂度： 求SA：$O(n\log_{2}n)$ 求Height：$O(n)$ st表的预处理：$O(n\log_{2}n)$ 单次回答：$O(1)$ 总计：$O(n\log_{2}n)$ 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std; const int maxn=100010;int n,m=122,q,sa[maxn],rnk[maxn],height[maxn],y[maxn],c[maxn],f[maxn][30],val[maxn];//f数组是st表，开到2的30次方已足够，val是预处理的log值，可以加快运算char s[maxn]; void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125; void getsa()&#123; int p=0,i,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]-96;//注意rnk一定要为正整数，否则会re、wa y[i]=i; &#125; sort(); for (k=1;p&lt;n;m=p,k&lt;&lt;=1) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125; void getheight()&#123; int i,j,k=0;/* for (i=1;i&lt;=n;i++) rnk[sa[i]]=i;*/ for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[j+k]==s[i+k]) k++; height[rnk[i]]=k; &#125;&#125; void init()&#123; int i,j; memset(f,0x3f,sizeof(f));//因为求min，所以要初始一个INF for (i=1;i&lt;=n;i++) f[i][0]=height[i]; for (j=1;j&lt;=val[n];j++)//先枚举幂，再枚举位置 for (i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);//注意是j-1而不是j&#125; int st(int l,int r)&#123; int k=val[r-l+1]; return min(f[l][k],f[r-(1&lt;&lt;k)+1][k]);//一定要+1&#125; int main()&#123; int i,j,k; scanf("%s",s+1); n=strlen(s+1); for (i=2;i&lt;=n;i++)//要从2开始算 val[i]=val[i&gt;&gt;1]+1; getsa(); getheight(); scanf("%d",&amp;q); init(); while (q--) &#123; scanf("%d%d",&amp;i,&amp;j); if (rnk[i]&gt;rnk[j])//如果排名是错的，那么先换位置 swap(i,j); if (i==j) printf("%d\n",n-i+1); //一样就不用算了 else printf("%d\n",st(rnk[i]+1,rnk[j]));//height[rnk[i]]表示的是rnk[i]与rnk[i]-1的LCP，不是计算的范围 &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>LZOJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>SA</tag>
        <tag>LCP</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月至5月停课·OI学习安排（一）]]></title>
    <url>%2F2019%2F04%2F10%2F2019%E5%B9%B44%E6%9C%88%E8%87%B35%E6%9C%88%E5%81%9C%E8%AF%BE%C2%B7OI%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说明现在不是为了准备比赛，只是为了学习更多的知识，为以后做好准备。我认为应该复习与学习相结合，学习一些省选必备知识点，练习各类的题目，力求一次学会。 学过的内容会复习一下，没有学过的就要把它学会。 这里先定了3周的内容，剩余的时间待安排。“week”按照停课开始的时间算，5个工作日左右为一周。 其中序号前有“-”的表示复习内容，有“*​”的表示选学内容（有时间就学，没时间可以先跳过），有“^”的表示重点，一定要掌握熟悉（至少做5道非模板题，宁愿一次过把内容学精，也不要后面准备比赛的时候再来着急）。 Week 1：字符串^1 后缀数组（SA）及其性质（学会利用SA与height的性质解决各类问题） ^2 后缀树与后缀自动机（SAM）（巧用树的性质来解决区间字符串问题） 3 回文算法（manacher）及回文自动机，回文树 -4 KMP及AC自动机 *5 Border的性质与周期 Week 2：数学^1 莫比乌斯函数与莫比乌斯反演（学会推式子） -2 线性筛 3 杜教筛（学会筛出μ和φ的前缀和） *4 洲阁筛 *5 Min_25筛 -6 欧拉函数 -7 费马小定理与欧拉定理 8 容斥原理 9 Lucas定理与扩展Lucas定理 ^10 和式与积式的推导与化简（用于优化顺序，降低常数等，可以应用于各类的题目） Week 3：数据结构^1 线段树（一定要学会线段树的各类高级操作，如合并分裂、二分、可持久化等，而且可以维护各种问题） *2 替罪羊树（一定要掌握思想，可以不打代码） -3 Treap（提升熟练度，最好做到15分钟内写完模板，而且习惯写指针版的平衡树） -4 Splay（提升熟练度，特别是区间翻转的部分） *5 树套树 6 Link-Cut-Tree -7 树链剖分（学一类长链剖分的题） *8 点分治 2019年4月10日星期三 上午9时整]]></content>
      <categories>
        <category>其他</category>
        <category>计划</category>
      </categories>
      <tags>
        <tag>安排</tag>
        <tag>近期计划</tag>
        <tag>学习内容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1031】【JSOI2007】字符加密cipher]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%90BZOJ1031%E3%80%91%E3%80%90JSOI2007%E3%80%91%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86cipher%2F</url>
    <content type="text"><![CDATA[Description喜欢钻研问题的JS同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。例如下图，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0​把它们按照字符串的大小排序：07JSOI 7JSOI0 I07JSO JSOI07​ OI07JS SOI07J读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？ Input输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。 Output输出一行，为加密后的字符串。 Sample Input$JSOI07$ Sample Output$I0O7SJ$ Hint对于$100$%的数据字符串的长度不超过$100000$。 题解知识点：后缀数组 分析：题目要求求出的最后一列是什么，关键在于排序，但是就这样排又会出错（复杂度不对）。所以考虑把整个字符串倍长一次，这样是一定不会影响后缀的大小的，而且倍长一次之后相当于做到收尾相接，而且后缀的排序就等同于整个环串的排序。所以采用后缀数组给$2n$的字符串排序，然后扫一次判断$sa[i]$是否在$n$以内，是的话就是答案了，然后$sa[i]-1$的这个位置在原串中的内容就是答案了（这种方法要预处理出$s[0]=s[n]$,或者可以直接找$sa[i]+n-1$在倍长串中的内容也可以）。所以最终的时间复杂度与普通的后缀排序等价（尽管n变成了2倍），还是$O(n\log_{2}n)$。 我在这道题上 $WA​$ 了$5​$次，最后的问题是后缀数组中第$1​$次运算时的计数器$p​$没有清$0​$,导致有可能在进入循环判断的时候直接超过了字符集的大小$m​$，导致计算出错。这种低级错误一定要避免。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=100010;//全都要开两倍空间，而且字符集初始大小定义为ASCII码的总数int n,sa[maxn&lt;&lt;1],rnk[maxn&lt;&lt;1],y[maxn&lt;&lt;1],c[maxn&lt;&lt;1],m=128;char s[maxn&lt;&lt;1];void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()//后缀排序的过程&#123; int p=0,k,i;//p一定要清0，否则会WA for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]; y[i]=i; &#125; sort(); for (k=1;k&lt;=n&amp;&amp;p&lt;n;k&lt;&lt;=1,m=p) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;int main()&#123; int i; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;i++)//倍长字符串 s[i+n]=s[i]; n&lt;&lt;=1; getsa(); n&gt;&gt;=1; s[0]=s[n];//首尾相接 for (i=1;i&lt;=(n&lt;&lt;1);i++)//判断是否在范围内，是的就是答案 if (sa[i]&lt;=n) putchar(s[sa[i]-1]); return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法优化DP的技巧]]></title>
    <url>%2F2019%2F04%2F03%2F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E4%BC%98%E5%8C%96DP%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文讲一下一些基本的矩阵优化DP的方法技巧。 定义三个矩阵A,B,C,其中行和列分别为$m\times n,n \times p,m\times p$，（其中行是从上往下数的，列是从左往右数的） $C_{i,j}=\sum_{k=1}^{n}A_{i,k}\times B_{k,j}$ 矩阵乘法具有结合律，但没有交换律，可以乘方、求逆。 做矩阵优化DP的题目步骤： $1\quad$把$DP$方程推出来（假如不能手推，可以先打$10$项左右的表，然后再写一个程序找每一项的系数，一般不会超过$5$项，否则矩阵太大了） $2\quad$打横把系数写出来（注意$i-1$先写，接下来是$i-2$，以此类推，没有的项补$0$） $3\quad$把矩阵补成项数$\times $项数，下面从第一个位置开始，对角线上写$1$（第一行忽略，其他写$0$） $4\quad$把初始矩阵按下标从大到小写出来，一定要打竖 $5\quad$把题目要求的第$n$项的先减去矩阵的边长，然后进行快速幂，最后初始矩阵的第一个数就是答案 其实大家可以用横着写初始矩阵，竖着写系数的方法理解，但是为了减少常数，我们不可能两个矩阵开到一样大，所以我们适应计算机的理解，竖着写更方便，而且基本正确。 还可以用判断是否为$0$、改变转移顺序、人工$mod$的速度来卡常数。 对于一些不止一维的题目，可以把后面几维顺着写下去（像二维并查集一样），有常数项的可以写到矩阵里面去。 理论时间复杂度：$O(\log_{2}({p^{2}\times n}))$其中$n$是要求的第n项答案，$p​$是矩阵的大小。]]></content>
      <categories>
        <category>算法总结</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
        <tag>计数DP</tag>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F04%2F03%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[$\quad$$\quad$非常高兴，终于把博客弄好了，在此鸣谢@CGY @CR两位大佬的帮助。 $\quad$$\quad​$学习OI已经差不多三年了，从进入这个圈子、参加人生的第一场竞赛，到现在热爱信息学竞赛，时间不多，也不少。投入可以在一定程度上决定产出，从以前付出很少，到现在经常利用课余时间学习OI，时间不多，也不少。重大的痛苦会改变人生态度，从觉得不用学得太多都可以拿到很高的奖项，到意识到自己原来在本市、本省是多么差劲的这种思想转变，时间不多，也不少。 $\quad$$\quad​$以前喜欢在网上看各位前辈高手写的博客，觉得很有意思，而且看到一篇有意义、讲的清楚明白的博客真的十分重要，它不仅能让我们了解表层的含义，还能够帮助我们省掉很多的时间。此外，还可以教会我们很多技巧、方法，让我们在做题的时候不用四处碰壁，避免了用很长的时间都换不回来有效的收益的情况。 $\quad$$\quad$尽管我水平很差，能力一般，但是我希望我能够从现在开始坚持写博客，一则帮助自己随时复习知识点，二则帮助更多以前向我一样渴望学习却找不到好资源的同学，我只把我会的、认为重要的分享给大家。大家一定要认真阅读，有问题请提出并共同探讨，多多斧正！ $\quad$$\quad$希望我们的OI之路能够一帆风顺，不断进步，取得优异的成绩！]]></content>
      <categories>
        <category>其他</category>
        <category>站务</category>
      </categories>
      <tags>
        <tag>我的第一篇博客</tag>
      </tags>
  </entry>
</search>
