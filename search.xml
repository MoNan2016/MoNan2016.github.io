<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【洛谷P2408】不同子串个数 以及此类问题的拓展]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90%E6%B4%9B%E8%B0%B7P2408%E3%80%91%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目背景因为NOI被虐傻了，蒟蒻的YJQ准备来学习一下字符串，于是它碰到了这样一道题： 题目描述给你一个长为$N$的字符串，求不同的子串的个数。 我们定义两个子串不同，当且仅当有这两个子串长度不一样 或者长度一样且有任意一位不一样。 子串的定义：原字符串中连续的一段字符组成的字符串。 输入输出格式输入格式：第一行一个整数$N$。 接下来一行$N$个字符表示给出的字符串。 输出格式：一行一个整数，表示不一样的子串个数。 题解：知识点：后缀数组，LCP 分析：其实求本质不同的子串的个数这类问题，很容易联想到后缀数据结构。其实可以发现子串不同相当于所有后缀的前缀不同的情况，所以我们把问题的统计变成了统计前缀的不同个数。 我们以$sa[1],sa[2],sa[3],sa[i] \cdots，sa[n]$的顺序统计每个$suffix$,可以发现每次加入的后缀的前缀的个数为$n-sa[i]+1$,但是这里面有很多是重复的，我们要把它们减掉，又$height[i]$的定义我们可以知道，既然前$i-1$处已经计算过$suffix(sa[i])的前height[i]$位了，那么我们把$height[i]$减掉就是答案了，这样就可以线性地解决问题。 时间复杂度：$O(n\log_{2}n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=100010;int n,m=128,sa[maxn],rnk[maxn],y[maxn],height[maxn],c[maxn];char s[maxn];long long ans;//答案会很大，要开够void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]; y[i]=i; &#125; sort(); for (k=1;p&lt;n;k&lt;&lt;=1,m=p) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,j,k=0; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[j+k]==s[i+k]) k++; height[rnk[i]]=k; &#125;&#125;int main()&#123; int i; scanf("%d%s",&amp;n,s+1); getsa(); getheight(); for (i=1;i&lt;=n;i++) ans+=n-sa[i]+1-height[i]; printf("%lld\n",ans); return 0;&#125; 现在我们考虑变成多组数据，在时间复杂度允许的情况下，直接搞就好了，但是注意字符集大小每次要恢复到128，数组要清空。(Eg.SPOJ694 705) 而LZOJ里面的那道把数据组数开到了$10^{3}$，但是同时字符集变小了，这样也是可以跑过去的（常数不能太大）。]]></content>
      <categories>
        <category>题目总结</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【POJ3261】milk patterns]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90POJ3261%E3%80%91milk-patterns%2F</url>
    <content type="text"><![CDATA[题解：知识点：后缀数组，二分，LCP，离散化 分析：按照罗穗骞的论文（《后缀数组—-处理字符串的有力工具》，IOI2009中国国家集训队论文集）中的说法，这种题型叫做: 可重叠的k 次最长重复子串 解决的方法是：先求出sa、height，然后二分长度$mid$，把一个求最大值问题转化成判定性问题。判定中，我们把height值大于等于$mid$的分组（即假如中间有一个height值小于mid，那么这个位置被分作下一组，然后再继续统计答案），假如一个组中的后缀个数大于等于$k$的话，这种情况就是成立的，然后继续缩小范围查找。 注意这道题的字符集大小太大了（虽然说数据太水了，不离散化也可以过），我们要先进行离散化，给字符重新定义一个值，然后再进行操作。 整个过程总的时间复杂度是：$O(n\log_{2}n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=20010;int n,m=20000,k,sa[maxn],a[maxn],_a[maxn],rnk[maxn],y[maxn],c[maxn],height[maxn],b[maxn],cnt;int read()&#123; int x=0,ff=1; char cc=getchar(); while (cc&lt;48||cc&gt;57) ff=cc=='-'?-1:1,cc=getchar(); while (cc&gt;=48&amp;&amp;cc&lt;=57) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(cc^48),cc=getchar(); return x*ff;&#125;void srt()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()&#123; int i,p=0,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=a[i];//因为已经离散化过了，所以可以直接用 y[i]=i; &#125; srt(); for (k=1;p&lt;n;m=p,k&lt;&lt;=1) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; srt(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;void getheight()&#123; int i,k=0,j; for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (a[i+k]==a[j+k]) k++; height[rnk[i]]=k; &#125;&#125;bool check(int len)&#123; int tot=1,i;//因为第一个位置虽然height为0，但是也是有一个，所以初始值为1 /*for (i=2;i&lt;=n;i++) &#123; if (height[i]&lt;len) &#123; if (tot&gt;=k) return 1; tot=1; &#125; else tot++; &#125; return 0;*/ for (i=2;i&lt;=n;i++) &#123; if (height[i]&lt;len) tot=1;//如果不满足，就新开一个组 else tot++;//否则就继续 if (tot&gt;=k)//已经成立就返回 return 1; &#125; return 0;&#125;int getnum(int x)//二分查找最接近的值，可以用stl的lower_bound来代替，不过手写常数小&#123; int l=1,r=cnt,mid; while (l&lt;=r) &#123; mid=(l+r+1)&gt;&gt;1; if (b[mid]==x) return mid; if (b[mid]&lt;x) l=mid+1; else r=mid-1; &#125;&#125;int main()&#123; int i,j; n=read(); k=read(); for (i=1;i&lt;=n;i++) a[i]=read(),_a[i]=a[i];//另开一个空间来存离散的东西 sort(_a+1,_a+n+1); for (i=1;i&lt;=n;i++) if (i==1||_a[i]!=_a[i-1]) b[++cnt]=_a[i];//去重，可以用一个stl函数代替 for (i=1;i&lt;=n;i++) a[i]=getnum(a[i]);//离散化 getsa(); getheight(); int l=1,r=n,mid; while (l&lt;r)//二分可行的长度 &#123; mid=(l+r+1)&gt;&gt;1; if (check(mid)) l=mid; else r=mid-1; &#125; printf("%d\n",l); return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>POJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>LCP</tag>
        <tag>离散化</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【LZOJ3071】后缀数组/后缀树2]]></title>
    <url>%2F2019%2F04%2F12%2F%E3%80%90LZOJ3071%E3%80%91%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84-%E5%90%8E%E7%BC%80%E6%A0%912%2F</url>
    <content type="text"><![CDATA[题解知识点：后缀数组，最长公共前缀 分析：这道题是一道lcp的入门题，主要是先求出SA，然后通过SA线性求出Height，最后预处理出ST表，然后每次访问的时候调用即可。细节较多，在代码中讲解。 时间复杂度： 求SA：$O(n\log_{2}n)$ 求Height：$O(n)$ st表的预处理：$O(n\log_{2}n)$ 单次回答：$O(1)$ 总计：$O(n\log_{2}n)$ 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std; const int maxn=100010;int n,m=122,q,sa[maxn],rnk[maxn],height[maxn],y[maxn],c[maxn],f[maxn][30],val[maxn];//f数组是st表，开到2的30次方已足够，val是预处理的log值，可以加快运算char s[maxn]; void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125; void getsa()&#123; int p=0,i,k; for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]-96;//注意rnk一定要为正整数，否则会re、wa y[i]=i; &#125; sort(); for (k=1;p&lt;n;m=p,k&lt;&lt;=1) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125; void getheight()&#123; int i,j,k=0;/* for (i=1;i&lt;=n;i++) rnk[sa[i]]=i;*/ for (i=1;i&lt;=n;i++) &#123; if (k) k--; j=sa[rnk[i]-1]; while (s[j+k]==s[i+k]) k++; height[rnk[i]]=k; &#125;&#125; void init()&#123; int i,j; memset(f,0x3f,sizeof(f));//因为求min，所以要初始一个INF for (i=1;i&lt;=n;i++) f[i][0]=height[i]; for (j=1;j&lt;=val[n];j++)//先枚举幂，再枚举位置 for (i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);//注意是j-1而不是j&#125; int st(int l,int r)&#123; int k=val[r-l+1]; return min(f[l][k],f[r-(1&lt;&lt;k)+1][k]);//一定要+1&#125; int main()&#123; int i,j,k; scanf("%s",s+1); n=strlen(s+1); for (i=2;i&lt;=n;i++)//要从2开始算 val[i]=val[i&gt;&gt;1]+1; getsa(); getheight(); scanf("%d",&amp;q); init(); while (q--) &#123; scanf("%d%d",&amp;i,&amp;j); if (rnk[i]&gt;rnk[j])//如果排名是错的，那么先换位置 swap(i,j); if (i==j) printf("%d\n",n-i+1); //一样就不用算了 else printf("%d\n",st(rnk[i]+1,rnk[j]));//height[rnk[i]]表示的是rnk[i]与rnk[i]-1的LCP，不是计算的范围 &#125; return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>LZOJ</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>SA</tag>
        <tag>LCP</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年4月至5月停课·OI学习安排（一）]]></title>
    <url>%2F2019%2F04%2F10%2F2019%E5%B9%B44%E6%9C%88%E8%87%B35%E6%9C%88%E5%81%9C%E8%AF%BE%C2%B7OI%E5%AD%A6%E4%B9%A0%E5%AE%89%E6%8E%92%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[说明现在不是为了准备比赛，只是为了学习更多的知识，为以后做好准备。我认为应该复习与学习相结合，学习一些省选必备知识点，练习各类的题目，力求一次学会。 学过的内容会复习一下，没有学过的就要把它学会。 这里先定了3周的内容，剩余的时间待安排。“week”按照停课开始的时间算，5个工作日左右为一周。 其中序号前有“-”的表示复习内容，有“*​”的表示选学内容（有时间就学，没时间可以先跳过），有“^”的表示重点，一定要掌握熟悉（至少做5道非模板题，宁愿一次过把内容学精，也不要后面准备比赛的时候再来着急）。 Week 1：字符串^1 后缀数组（SA）及其性质（学会利用SA与height的性质解决各类问题） ^2 后缀树与后缀自动机（SAM）（巧用树的性质来解决区间字符串问题） 3 回文算法（manacher）及回文自动机，回文树 -4 KMP及AC自动机 *5 Border的性质与周期 Week 2：数学^1 莫比乌斯函数与莫比乌斯反演（学会推式子） -2 线性筛 3 杜教筛（学会筛出μ和φ的前缀和） *4 洲阁筛 *5 Min_25筛 -6 欧拉函数 -7 费马小定理与欧拉定理 8 容斥原理 9 Lucas定理与扩展Lucas定理 ^10 和式与积式的推导与化简（用于优化顺序，降低常数等，可以应用于各类的题目） Week 3：数据结构^1 线段树（一定要学会线段树的各类高级操作，如合并分裂、二分、可持久化等，而且可以维护各种问题） *2 替罪羊树（一定要掌握思想，可以不打代码） -3 Treap（提升熟练度，最好做到15分钟内写完模板，而且习惯写指针版的平衡树） -4 Splay（提升熟练度，特别是区间翻转的部分） *5 树套树 6 Link-Cut-Tree -7 树链剖分（学一类长链剖分的题） *8 点分治 2019年4月10日星期三 上午9时整]]></content>
      <categories>
        <category>其他</category>
        <category>计划</category>
      </categories>
      <tags>
        <tag>安排</tag>
        <tag>近期计划</tag>
        <tag>学习内容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1031】【JSOI2007】字符加密cipher]]></title>
    <url>%2F2019%2F04%2F09%2F%E3%80%90BZOJ1031%E3%80%91%E3%80%90JSOI2007%E3%80%91%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86cipher%2F</url>
    <content type="text"><![CDATA[Description喜欢钻研问题的JS同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。例如下图，可以读作： JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0​把它们按照字符串的大小排序：07JSOI 7JSOI0 I07JSO JSOI07​ OI07JS SOI07J读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？ Input输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。 Output输出一行，为加密后的字符串。 Sample Input$JSOI07$ Sample Output$I0O7SJ$ Hint对于$100$%的数据字符串的长度不超过$100000$。 题解知识点：后缀数组 分析：题目要求求出的最后一列是什么，关键在于排序，但是就这样排又会出错（复杂度不对）。所以考虑把整个字符串倍长一次，这样是一定不会影响后缀的大小的，而且倍长一次之后相当于做到收尾相接，而且后缀的排序就等同于整个环串的排序。所以采用后缀数组给$2n$的字符串排序，然后扫一次判断$sa[i]$是否在$n$以内，是的话就是答案了，然后$sa[i]-1$的这个位置在原串中的内容就是答案了（这种方法要预处理出$s[0]=s[n]$,或者可以直接找$sa[i]+n-1$在倍长串中的内容也可以）。所以最终的时间复杂度与普通的后缀排序等价（尽管n变成了2倍），还是$O(n\log_{2}n)$。 我在这道题上 $WA​$ 了$5​$次，最后的问题是后缀数组中第$1​$次运算时的计数器$p​$没有清$0​$,导致有可能在进入循环判断的时候直接超过了字符集的大小$m​$，导致计算出错。这种低级错误一定要避免。 最后贴上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn=100010;//全都要开两倍空间，而且字符集初始大小定义为ASCII码的总数int n,sa[maxn&lt;&lt;1],rnk[maxn&lt;&lt;1],y[maxn&lt;&lt;1],c[maxn&lt;&lt;1],m=128;char s[maxn&lt;&lt;1];void sort()&#123; int i; memset(c,0,sizeof(c)); for (i=1;i&lt;=n;i++) c[rnk[i]]++; for (i=2;i&lt;=m;i++) c[i]+=c[i-1]; for (i=n;i&gt;=1;i--) sa[c[rnk[y[i]]]--]=y[i];&#125;void getsa()//后缀排序的过程&#123; int p=0,k,i;//p一定要清0，否则会WA for (i=1;i&lt;=n;i++) &#123; rnk[i]=s[i]; y[i]=i; &#125; sort(); for (k=1;k&lt;=n&amp;&amp;p&lt;n;k&lt;&lt;=1,m=p) &#123; p=0; for (i=n-k+1;i&lt;=n;i++) y[++p]=i; for (i=1;i&lt;=n;i++) if (sa[i]&gt;k) y[++p]=sa[i]-k; sort(); swap(rnk,y); rnk[sa[1]]=p=1; for (i=2;i&lt;=n;i++) rnk[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?p:++p; &#125;&#125;int main()&#123; int i; scanf("%s",s+1); n=strlen(s+1); for (i=1;i&lt;=n;i++)//倍长字符串 s[i+n]=s[i]; n&lt;&lt;=1; getsa(); n&gt;&gt;=1; s[0]=s[n];//首尾相接 for (i=1;i&lt;=(n&lt;&lt;1);i++)//判断是否在范围内，是的就是答案 if (sa[i]&lt;=n) putchar(s[sa[i]-1]); return 0;&#125;]]></content>
      <categories>
        <category>题目总结</category>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
        <tag>SA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法优化DP的技巧]]></title>
    <url>%2F2019%2F04%2F03%2F%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E4%BC%98%E5%8C%96DP%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[本文讲一下一些基本的矩阵优化DP的方法技巧。 定义三个矩阵A,B,C,其中行和列分别为$m\times n,n \times p,m\times p$，（其中行是从上往下数的，列是从左往右数的） $C_{i,j}=\sum_{k=1}^{n}A_{i,k}\times B_{k,j}$ 矩阵乘法具有结合律，但没有交换律，可以乘方、求逆。 做矩阵优化DP的题目步骤： $1\quad$把$DP$方程推出来（假如不能手推，可以先打$10$项左右的表，然后再写一个程序找每一项的系数，一般不会超过$5$项，否则矩阵太大了） $2\quad$打横把系数写出来（注意$i-1$先写，接下来是$i-2$，以此类推，没有的项补$0$） $3\quad$把矩阵补成项数$\times $项数，下面从第一个位置开始，对角线上写$1$（第一行忽略，其他写$0$） $4\quad$把初始矩阵按下标从大到小写出来，一定要打竖 $5\quad$把题目要求的第$n$项的先减去矩阵的边长，然后进行快速幂，最后初始矩阵的第一个数就是答案 其实大家可以用横着写初始矩阵，竖着写系数的方法理解，但是为了减少常数，我们不可能两个矩阵开到一样大，所以我们适应计算机的理解，竖着写更方便，而且基本正确。 还可以用判断是否为$0$、改变转移顺序、人工$mod$的速度来卡常数。 对于一些不止一维的题目，可以把后面几维顺着写下去（像二维并查集一样），有常数项的可以写到矩阵里面去。 理论时间复杂度：$O(\log_{2}({p^{2}\times n}))$其中$n$是要求的第n项答案，$p​$是矩阵的大小。]]></content>
      <categories>
        <category>算法总结</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
        <tag>快速幂</tag>
        <tag>DP</tag>
        <tag>计数DP</tag>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Blog]]></title>
    <url>%2F2019%2F04%2F03%2FMy-First-Blog%2F</url>
    <content type="text"><![CDATA[$\quad$$\quad$非常高兴，终于把博客弄好了，在此鸣谢@CGY @CR两位大佬的帮助。 $\quad$$\quad​$学习OI已经差不多三年了，从进入这个圈子、参加人生的第一场竞赛，到现在热爱信息学竞赛，时间不多，也不少。投入可以在一定程度上决定产出，从以前付出很少，到现在经常利用课余时间学习OI，时间不多，也不少。重大的痛苦会改变人生态度，从觉得不用学得太多都可以拿到很高的奖项，到意识到自己原来在本市、本省是多么差劲的这种思想转变，时间不多，也不少。 $\quad$$\quad​$以前喜欢在网上看各位前辈高手写的博客，觉得很有意思，而且看到一篇有意义、讲的清楚明白的博客真的十分重要，它不仅能让我们了解表层的含义，还能够帮助我们省掉很多的时间。此外，还可以教会我们很多技巧、方法，让我们在做题的时候不用四处碰壁，避免了用很长的时间都换不回来有效的收益的情况。 $\quad$$\quad$尽管我水平很差，能力一般，但是我希望我能够从现在开始坚持写博客，一则帮助自己随时复习知识点，二则帮助更多以前向我一样渴望学习却找不到好资源的同学，我只把我会的、认为重要的分享给大家。大家一定要认真阅读，有问题请提出并共同探讨，多多斧正！ $\quad$$\quad$希望我们的OI之路能够一帆风顺，不断进步，取得优异的成绩！]]></content>
      <categories>
        <category>其他</category>
        <category>站务</category>
      </categories>
      <tags>
        <tag>我的第一篇博客</tag>
      </tags>
  </entry>
</search>
